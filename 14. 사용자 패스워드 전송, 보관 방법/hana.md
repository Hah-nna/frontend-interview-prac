# 사용자 패스워드를 전송하고 보관하는 방법을 설명해주실 수 있을까요?

## 대략적인 과정

클라이언트에서 사용자의 패스워드를 평문(암호화되기 전 메시지)으로 전송 -> 서버는 평문 패스워드를 단방향 해시 함수* 로 암호화* 해서 보관함 -> 그러나 단방향 해시 함수에도 단점* 이 있기 때문에 이를 보완하기 위해 key stretching*, salting\* 등을 이용해 보안성을 높임

\*암호화
어떤 데이터를 암호화해 타인이 직접 그 의미를 알지 못하도록 하는 작업

\*복호화
암호화되어있는 데이터를 해독하는 작업

\*단방향 해시 함수
어떤 수학적 연산(또는 알고리즘)에 의해 원본 데이터를 매핑시켜 완전히 다른 암호화된 데이터로 변환시키는 것. 이 변환을 **해시**라고 하고 해시에 의해 암호화된 데이터를 **다이제스트**라고 함

해시는 단방향이기 때문에 단방향 해시함수는 원본 데이터를 구할 수 없어야 함(복호화X)
예를 들면 아래와 같음

<img src="https://img1.daumcdn.net/thumb/R1600x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FDMi4A%2FbtqEnh26qKT%2F0uDU6AK5mqEE3XGHhoWL41%2Fimg.png">

평문이 해시함수를 거쳐 다이제스트인 f~~를 생성하고 해당 데이터를 DB에 저장하는 것임
저장된 다이제스트는 단방향으로 해싱된 문자라 복호화할 수 없음

단방향 해시 함수의 종류: SHA-256, MD, HAS, WHIRPOOL

sha-256으로 123456을 해싱하면 아래와 같음

```
8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92
```

=> 유저로부터 입력받은 정보를 해싱해서 저장해 기존 패스워드를 유추하기 어렵게 함

\*단방향 해시 함수의 단점

- 동일한 메시지(평문)는 동일한 다이제스트를 가짐
  위의 예시에서 123456을 해싱한 결과인 fs32a3xx0(다이제스트)으로 원래의 메시지(평문)을 유추하기 어려움
  하지만 123456에 대한 다이제스트(fs32a3xx0)는 항상 같은 값을 얻음.

항상 같은 값을 가지다보니 이런 다이제스트들을 모아놓은 리스트가 있음 이를 레인보우 테이블이라 함
(sha-256 rainbow table이라고 검색하면 관련 사이트들 나옴)

예를 들면 123456을 모른다고 가정하고 다이제스트만 안다는 가정하에 sha-256으로 해싱했던 값을 sha-256 rainbow table이라고 검색했을 때 나오는 아무 사이트에 들어가서 돌려보니
어떤 해시함수를 썼고 원래의 평문이 무엇이었는지를 알려줌

복잡하지 않거나 많은 사람들이 사용하는 패스워드의 경우 이미 해당 패스워드의 다이제스트가 레인보우 테이블에 있을 가능성이 높음 -> 다이제스트를 통해 원래의 패스워드를 알 수 있기 때문에 패스워드 노출의 위험성이 큼

- 무차별 대입 공격(brute-force attack)
  원래 해시함수는 패스워드 저장이 아니라 빠른 데이터 검색을 위해 설계됨. 그래서 해시 함수를 사용하면 다이제스트가 빨리 얻어짐. 이렇게 우리가 빨리 다이제스트를 얻을 수 있는 것처럼 해커도 똑같이 빠르게 값을 얻을 수 있음. 즉, 해시의 빠른 처리속도를 통해 해커는 무작위의 데이터들을 계속 대입하면서 얻은 다이제스트와 해킹할 대상의 다이제스트를 계속 비교할 수 있음. 해커는 다이제스트를 빨리 얻을 수 있으므로 그만큼 빨리 해킹할 가능성 높아짐

이러한 단점들을 보완하기 위해 나온 것이 key stretching과 salt임

\*key stretching
해시 함수를 여러 번 수행해 다이제스트를 암호화하는 작업.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FTUkQh%2FbtqEmwtzk5G%2F7ls4aF6Plv0rDigk9rEtDK%2Fimg.png">

해시 함수를 여러 번 수랭하는 만큼 최종 다이제스트를 얻는데 시간이 함수를 수행한 만큼 걸림
따라서 해커의 입장에서는 다이제스틑 얻는데 걸리는 시간이 더 많이 듦.
즉, 브루트포스를 무력화시킬 수 있음

\*salt
key stretching 방법을 사용해도 결국 몇 번 해시함수를 수행했는지 횟수만 알면 해커의 입장에서는 다이제스트를 찾는 시간을 줄일 수 있고, 횟수별 다이제스트가 레인보우 테이블에 있을 가능성이 있음. 또한 같은 패스워드를 사용하는 사용자들이 있다면 하나의 결과를 가지고도 다수의 유저의 패스워드를 아는 것과 마찬가지임. 따라서 이를 방지하기 위해 나온 것이 솔팅(salting)임

salt: 단방향 해시 함수에서 다이제스트를 생성할 때 추가되는 바이트 단위의 임의의 문자열
salting: 원본 메시지(평문)에 솔트를 추가하여 다이제스트를 생성하는 것

예를 들면 아래의 그림과 같음

<img src="https://d2.naver.com/content/images/2015/06/helloworld-318732-1.png">

솔팅을 사용하면 해커가 redFlOwer의 다이제스트를 알아내도 솔팅된 다이제스트를 대상으로 패스워드 일치 여부를 확인하기 어려움. 그리고 유저별로 고유의 솔트를 가진다면(사용자별로 다른 솔트를 가진다면) 유저의 다이제스트가 다르게 생성되어 인식 가능성 문제가 크게 개선됨.

솔팅을 사용할 때는 모든 패스워드가 자신만의 고유한 솔트를 갖고, 솔트의 길이는 32바이트 이상이어야 솔트와 다이제스트를 추측하기 어려움

그럼 ket stretching과 salting를 섞어서 남들이 풀 수 없는 나만의 암호화 시스템을 만들어서 적용하면 되겠네! -> 에러나 취약점을 확인하기 어려움. 이미 검증된 방법을 사용하는 게 훨씬 나음

\*\*Adaptive key derivation functions
다이제스트 생성 시 salting 외에도 다른 입력값을 추가해 다이제스트의 유추를 어렵게 하는 함수. 보안의 강도를 선택할 수 있음.
검증된 종류는 아래와 같음

- PBKDF2 : 솔트를 적용한 후 해시 함수의 반복 횟수를 정할 수 있음. 미국 정부 시스템에서 유저 비밀번호에 사용
- bcrypt : 패스워드 저장 목적으로 사용. 다양한 언어에서 라이브러리로 제공됨
- scrypt : 다이제스트 생성 시 오버헤드를 갖게해 브루트포스가 어려움. 보안에 아주 민감한 경우에 사용

=> 매우 강력한 패스워스 다이제스트를 생성하는 시스템을 쉽게 구현하고 싶다면 bcrypt를 사용하는 것이 좋음. 왜냐하면 대부분의 프로그래밍 언어에서 라이브러리를 사용할 수 있고 예제를 쉽게 구할 수 있기 때문임

구현하려는 시스템이 민감한 정보를 다루고 보안 시스템을 구현하는 데 많은 비용을 투자할 수 있다면 scrypt를 사용하면 됨

**참조**

- https://d2.naver.com/helloworld/318732
- https://st-lab.tistory.com/100
- https://parksunwoo.github.io/dev/2023/03/05/how-to-transfer-archive-user-password.html
- https://jindevelopetravel0919.tistory.com/39
- https://fullbackgee.tistory.com/99
