# 상태의 불변성이 중요한 이유가 무엇인가요?

**참고**
불변성에 대한 내용은 07.깊은 복사와 얕은 복사에 적어놓음!

유지보수가 쉽고 가독성이 좋은 코드를 작성할 수 있기 떄문입니다.
불변성을 지키지 않는다면 데이터가 어디서 어떻게 바뀌는지 파악하기 어렵고 이는 버그나 사이드 이펙트로 이어질 수 있기 때문임.
따라서 불변성을 지키면 데이터가 변경될 때마다 새로운 참조를 생성하기 때문에 변경된 부분을 명확하게 추적할 수 있음. 따라서 코드에서 데이터 변화를 예측하기 쉬워져서 버그 발생 가능성을 줄일 수 있고 사이드 이펙트도 방지할 수 있음

```
const user = [
{
 id: 1,
 nickName: 'ggg'
},
{
 id: 2,
 nickName: 'hhh'
}
]

const user2 = user;

user[0].nickName = 'okok';

console.log(user) // [{id:1, nickName: 'okok'},{id:2, nickName: 'hhh'}]
console.log(user2) // [{id:1, nickName: 'okok'},{id:2, nickName: 'hhh'}]
console.log(user === user2) // true

```

위의 예시같이 user[0]번째의 이름만 바꾸고 싶었는데 user2의 0번째 이름도 바뀌어버림. 이는 의도치 않은 동작임. 따라서 배열이나 객체 타입(참조형 데이터)의 경우 내부 요소를 직접 수정하기 보다는 map이나 스프레드 연산자 등을 써서 기존 요소들을 포함한 새로운 객체 혹은 배열을 생성함으로써 불변성을 유지해야할 수 있음

이런 상태 불변성은 리액트의 상태관리에서도 사용됨
예를 들면 const [item, setItem] = useState(['apple', 'banana', 'orange'])라는 배열을 가진 state가 있다고 가정함
여기에 'peach'를 추가한다고 했을 때 item.push('peach')를 한다면 직접 변경을 하는 것이기 때문에 리액트는 item 배열의 변화를 알지 못함(변경을 할 떄는 setState를 사용해 이전 상태와는 별개의 새로운 상태를 생성하기 때문)
따라서 불변성을 유지하면서 상태를 변경하려면 리액트에서는 다음과 같이 할 수 있음

```
setItem([...item, 'peach'])
```

스프레드 연산자를 사용해 기존 item의 요소들을 새로운 배열에 복사 후 'peach'라는 새로운 요소를 새로운 배열에 추가함. 그러면 기존 item배열은 변하지 않고 기존의 item 배열과는 별개의 새로운 배열이 생성되어 state가 업데이트 됨
