# 시간복잡도와 공간복잡도가 무엇인지 설명해주실 수 있을까요?

## 빅오 표기법(Big-O notation)

<img src="https://misc-flexiple.s3.amazonaws.com/bon_cheat_sheet.jpg" width="50%" height="50%">

- 알고리즘의 효율성을 평가하기 위한 분석법을 말함
- 시간 복잡도(실행 시간)와 공간 복잡도(실행 공간)로 이루어짐

### 알고리즘이란?

- 어떤 목적을 달성하거나 결과물을 만들어내기 위해 거쳐야하는 일련의 과정들
- 가는 루트는 다양하고 여러가지 상황에 따른 알고리즘은 모두 다름 -> 시간 복잡도(실행 시간)가 가장 낮은 알고리즘 선택해서 사용함

알고리즘의 실행 시간은 컴퓨터의 처리속도, 사용된 언어, 컴파일러의 속도에 달려있음
알고리즘의 실행 시간을 두 가지로 나눠보면 다음과 같음

1. 입력값의 크기에 따라 알고리즘의 실행 시간을 검증해볼 수 있음
2. 입력값의 크기에 따른 함수의 증가량(성장률)

이때 중요하지 않은 상수와 계수들을 제거 -> 알고리즘의 실행 시간에서 중요한 **성장률**을 볼 수 있음 -> 이를 **점근적 표기법(Asymptotic notation)**\* 이라 부름(가장 큰 영향을 주는 항만 계산함)

\*점근적 표기법(Asymptotic notation)은 아래와 같이 세 가지가 있고, 시간 복잡도를 나타내는 데 사용됨

- 최상의 경우(Best case) - 오메가 표기법(Big-Ω Notation) : 최적의 입력을 한 상태에서, 작업을 완료하는 데 가장 연산 횟수가 적은 경우
- 최악의 경우(Worst case) - 빅오 표기법 (Big-O Notation) : 최악의 입력을 한 상태에서 작업을 완료하는 데 가장 연산 횟수가 많은 경우
- 평균의 경우(Average case) - 세타 표기법 (Big-θ Notation) : 여러 경우의 수를 고려해 총 연산 횟수를 계산하고 시행 횟수로 나누는 경우

=> 평균인 세타 표기법은 평가하기에 까다로움. 따라서 최악의 경우인 빅오 표기법을 사용함. 왜냐하면 알고리즘의 최악일 때의 경우를 판단하면 평균과 가장 가까운 성능으로 예측하기 쉽기 때문임

## 시간 복잡도

- 특정한 입력에 대해 알고리즘이 얼마나 오래 걸리는지를 의미함. 이때 실행 시간이 아닌 **연산 횟수**를 기준으로 하는데, 명령어의 실행 시간이 컴퓨터 하드웨어 또는 프로그래밍 언어에 따라 달라지기 때문에 실행횟수만을 고려하기 때문임
- 알고리즘이 복잡해질수록 평균을 구하기 어려워져 가장 최악의 상황을 계산함 -> 빅오 표기법을 사용해 표기함

시간 복잡도에서 가장 큰 영향을 미치는 단위는 n의 단위임

```
1 -> O(1) -> 상수
2n + 30 -> O(n) -> n
3n^2 -> O(n^2) -> n^2
```

**O(1) < O(logN) < O(N) < O(NlogN) < O(N<sup>2</sup>) < O(2<sup>N</sup>)**
오른쪽으로 갈수록 성능이 떨어지고, 시간 복잡도가 좋지 않은 알고리즘임

빅오 표기법으로 시간 복잡도를 구하는 과정의 예시를 보고 싶다면 [여기](https://velog.io/@cksal5911/%EB%B9%85%EC%98%A4%ED%91%9C%EA%B8%B0%EB%B2%95-%EC%A0%95%EB%A6%AC-with-JS) 참고하길...

그래도 표로 간단히 시간 복잡도와 예시를 설명해보자면 아래 표와 같음

| 복잡도           | 소요시간       | 예시                                        |
| ---------------- | -------------- | ------------------------------------------- |
| O(1)             | 상수 시간      | 스택의 push, pop                            |
| O(logN)          | 로그 시간      | 이진 트리                                   |
| O(n)             | 직선적 시간    | for문                                       |
| O(NlogN)         | 선형 로그 시간 | 퀵 정렬, 병합 정렬, 힙 정렬                 |
| O(n<sup>2</sup>) | 2차 시간       | 이중 for문, 삽입 정렬, 버블 정렬, 선택 정렬 |
| O(2<sup>N</sup>) | 지수 시간      | 피보나치 수열                               |

### 시간 복잡도를 줄이는 방법

1. 효율적인 알고리즘 선택
   알고리즘의 시간 복잡도는 알고리즘의 효율성에 직결됨 -> 따라서 문제에 대해 더 효율적인 알고리즘 선택

2. 데이터 구조 최적화
   문제에 따라 효율적인 데이터 구조를 선택하고 활용하는 해야함
   ex: 검색 작업 -> 이진 검색 트리(자료구조) 사용 -> 검색 시간 줄임

3. 데이터 사전 처리
   입력 데이터를 사전에 처리해 계산을 간소화, 중복된 계산 피할 수 있음 -> 실행 시간 줄임

## 공간 복잡도

- 알고리즘을 수행하는 데 필요한 저장공간\*의 양을 의미함
- 빅오 표기법을 사용해 표기함

\*총 필요한 저장 공간

- 고정 공간 : 프로그램이 시작되기 전 결정하는 요소(ex: 명령어, 고정 크기 변수, 상수 등 )
- 가변 공간 : 프로그램 실행 중에 요구되는 요소(ex: 배열 전달, 재귀 호출 등)

### 공간 복잡도를 줄이는 방법

시간적인 측면을 무시하고 공간 복잡도만 고려한다면 고정 공간보다는 가변 공간을 사용하는 것이 더 효율적임. 불필요한 공간을 차지하는 변수를 최소화하는 것이 좋음

**참고**

- https://www.bigocheatsheet.com/
- https://velog.io/@welloff_jj/Complexity-and-Big-O-notation#-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84-time-complexity
- https://flexiple.com/algorithms/big-o-notation-cheat-sheet
- https://blog.chulgil.me/algorithm/
- https://soojae.tistory.com/15
- https://callmedevmomo.medium.com/%EC%9B%B9-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-01-%EB%B9%85%EC%98%A4-%ED%91%9C%EA%B8%B0%EB%B2%95-ff369f0efc1d
