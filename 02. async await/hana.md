# async/await 이란 무엇인지 설명해주실 수 있을까요?

promise를 좀 더 편하게 사용할 수 있는 자바스크립트 문법입니다
기존의 promise.then 보다 가독성이 좋고 쓰기도 쉬운 비동기 코드를 작성할 수 있습니다

## async

함수 앞에 async를 붙이면 해당 함수는 항상 프로미스를 반환합니다. 프로미스가 아닌 것은 프로미스로 감싸
반환합니다.

## await

자바스크립트는 await 키워드를 만나면 프로미스가 처리될 때까지 기다립니다.
결과는 프로미스가 처리된 후 반환됩니다.
말 그대로 프로미스가 처리될 때까지 함수 실행을 기다리게 만들기 때문에 프로미스가 처리되면 그 결과와 함께 실행이 재개됩니다.
프로미스가 처리되길 기다리는 동안 자바스크립트 엔진은 다른 일(다른 스크립트 실행, 이벤트 처리 등)을 할 수 있기 때문에
CPU 리소스가 낭비되지 않습니다
또한 await는 async 함수 안에서만 동작한다고 알고 있었는데 ES2022부터는 top-level-await도 가능해졌습니다
[참조](https://fe-developers.kakaoent.com/2022/220728-es2022/)

```
async function f() {

  let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve("완료!"), 1000)
  });

  let result = await promise; // 프라미스가 이행될 때까지 기다림 (*)

  alert(result); // "완료!"
}

f();
```

위의 예제에서 함수를 호출하고(f()) 함수가 실행되는 중에 \*로 표시된 줄에서 실행이 잠시 중단(프로미스가 처리될 떄까지 잠시 중단)
프로미스가 처리되면 다시 실행이 됩니다. 프로미스 객체의 결과값이 변수 result에 할당되기 때문에 위 예시는
1초 후에 '완료!'가 출력됩니다

## 에러 핸들링

프로미스가 거부 되기 전에 시간이 약간 지체되는 경우도 있습니다. 일반적으로는 비동기 작업에 시간이 걸리기 때문입니다
예를 들어 아래의 코드에서 사용된 fetch 함수는 네트워크 요청을 수행하고 해당 주소로부터 데이터를 가저오려고 합니다.
그런데 유효하지 않은 주소를 사용한 경우 프로미스가 바로 거부되지 않습니다. 대신 네트워크 요청을 다시 보내고
서버로부터 응답을 기다리는 시간이 일시적으로 지연될 수 있습니다. 프로미스가 최종적으로 거부될 때까지
await는 기다리게 됩니다 따라서 이런 경우 await가 에러를 던지기 전에 지연이 발생합니다
try...catch를 사용하면 프로미스가 최종적으로 거부되기 전까지 기다리지 않고 바로 await에서 던전 에러를 잡을 수 있습니다
try 블록 안의 코드가 실행되는 동안 발생하는 에러는 catch에서 잡아 실행할 수 있습니다
따라서 try 블록 안에서 프로미스를 호출하면 프로미스가 최종적으로 처리되는 것과 상관없이 바로 catch
블록으로 이동해 에러를 잡을 수 있습니다

```
async function f() {

  try {
    let response = await fetch('http://유효하지-않은-주소');
  } catch(err) {
    alert(err); // TypeError: failed to fetch
  }
}

f();

```

예시 코드에서 함수 f는 프로미스를 반환하는데, catch는 이 프로미스가 거부되면(네트워크 요청이 실패하면)
즉시 실행되어 에러 메세지를 출력됩니다. 즉 기다리지 않고 에러를 바로 잡을 수 있습니다
